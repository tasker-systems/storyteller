#!/usr/bin/env bash
# =============================================================================
# setup-env.sh — Modular .env assembly for storyteller
# =============================================================================
# Assembles .env from modular snippets in config/dotenv/.
# Adapted from tasker-core's setup-env.sh pattern.
#
# Usage:
#   ./cargo-make/scripts/setup-env.sh [--mode=MODE] [--output=PATH] [--dry-run] [--help]
#
# Modes:
#   dev      — base.env only (development defaults)
#   test     — base.env + test.env (unit tests)
#   test-ml  — base.env + test.env + test-ml.env (ML model tests)
#   test-llm — base.env + test.env + test-ml.env (LLM integration tests)

set -euo pipefail

# Defaults
MODE="test"
OUTPUT=""
DRY_RUN=false
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WORKSPACE_PATH="$(cd "${SCRIPT_DIR}/../.." && pwd)"
DOTENV_DIR="${WORKSPACE_PATH}/config/dotenv"

usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Assemble .env from modular snippets in config/dotenv/.

Options:
  --mode=MODE     Environment mode: dev, test (default), test-ml, test-llm
  --output=PATH   Output file path (default: WORKSPACE_PATH/.env)
  --dry-run       Print assembled env to stdout without writing
  --help          Show this help message
EOF
    exit 0
}

# Parse arguments
for arg in "$@"; do
    case "$arg" in
        --mode=*)   MODE="${arg#*=}" ;;
        --output=*) OUTPUT="${arg#*=}" ;;
        --dry-run)  DRY_RUN=true ;;
        --help)     usage ;;
        *)          echo "Unknown argument: $arg" >&2; exit 1 ;;
    esac
done

# Set default output path
if [[ -z "$OUTPUT" ]]; then
    OUTPUT="${WORKSPACE_PATH}/.env"
fi

# Determine which env files to layer
FILES=("${DOTENV_DIR}/base.env")

case "$MODE" in
    dev)
        # Base only
        ;;
    test)
        FILES+=("${DOTENV_DIR}/test.env")
        ;;
    test-ml|test-llm)
        FILES+=("${DOTENV_DIR}/test.env")
        FILES+=("${DOTENV_DIR}/test-ml.env")
        ;;
    *)
        echo "Error: Unknown mode '${MODE}'. Use dev, test, test-ml, or test-llm." >&2
        exit 1
        ;;
esac

# Verify all files exist
for file in "${FILES[@]}"; do
    if [[ ! -f "$file" ]]; then
        echo "Error: Missing env file: $file" >&2
        exit 1
    fi
done

# Assemble: concatenate files, deduplicate (last wins), expand ${WORKSPACE_PATH}.
# Uses awk compatible with macOS (BSD awk) and GNU awk.
assemble() {
    echo "# Generated by setup-env.sh --mode=${MODE}"
    echo "# $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo ""

    cat "${FILES[@]}" | awk -v ws="${WORKSPACE_PATH}" '
        /^[[:space:]]*#/ { next }
        /^[[:space:]]*$/ { next }
        {
            # Split on first = to get key and value
            eq = index($0, "=")
            if (eq == 0) next
            key = substr($0, 1, eq - 1)
            val = substr($0, eq + 1)
            # Validate key looks like an env var name
            if (key !~ /^[A-Za-z_][A-Za-z0-9_]*$/) next
            # Track insertion order
            if (!(key in seen)) {
                order[++n] = key
                seen[key] = 1
            }
            vals[key] = val
        }
        END {
            for (i = 1; i <= n; i++) {
                k = order[i]
                v = vals[k]
                # Expand ${WORKSPACE_PATH}
                gsub(/\$\{WORKSPACE_PATH\}/, ws, v)
                print k "=" v
            }
        }
    '
}

assembled="$(assemble)"

if $DRY_RUN; then
    echo "$assembled"
else
    echo "$assembled" > "$OUTPUT"
    echo "Generated ${OUTPUT} (mode=${MODE}, files=${#FILES[@]})"
fi
