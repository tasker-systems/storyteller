# Entity Model

## Purpose

This document specifies the Entity model — the unified representation for everything in the system, from a cup on a shelf to a mountain range to a protagonist. It operationalizes the communicability gradient from `world_design.md` and the "everything is an Entity" design decision from the tensor schema spec.

The core claim: there is one Entity type. What differs between a prop, a presence, a condition, and a character is not their *type* but their *component configuration* — which capabilities, communicability dimensions, and persistence characteristics they currently have. This configuration changes over time through a promotion/demotion lifecycle driven by interaction, narrative weight, and decay.

### Relationship to Other Documents

- **`world_design.md`** establishes the philosophical case: the binary of agent and prop is wrong. The communicability gradient is the alternative.
- **`tensor-schema-spec.md`** defines the element types (PersonalityAxis, Motivation, etc.) that entities can acquire as components. Decision 3 in that document establishes the Entity model at the architectural level.
- **This document** specifies the Entity lifecycle, component structure, communicability profile, decay mechanics, and ECS implementation strategy.

---

## The Unified Entity

Every thing in the world that the system may need to reason about is an Entity. An Entity is an identifier with a set of attached components. The components determine what the entity *is* — what it can do, how it communicates, how it persists, how other entities relate to it.

```
Entity {
  id: EntityId,           // unique, stable identifier
  components: ComponentSet // dynamic — components added and removed over lifecycle
}
```

This is deliberately minimal. The Entity itself has no inherent properties beyond its identity. Everything else — name, communicability, tensor elements, relational edges, decay rate — is a component that can be attached, modified, or removed.

### Why Not a Type Hierarchy?

The taxonomy in `world_design.md` — Characters, Presences, Conditions, Props — describes a spectrum, not a classification. An entity's position on that spectrum changes as the story develops. The ring on the table is a prop until someone notices it, a presence once it carries narrative weight, and approaches character-level communicability if the story gives it enough accumulated meaning.

A type hierarchy (Character extends Presence extends Prop) would make these transitions awkward — casting, downcasting, migration between types. A component model makes them natural: promotion adds components, demotion removes them. The entity's identity is stable throughout.

---

## Component Architecture

Components fall into several categories, each governing a different aspect of the entity's participation in the system.

### Identity Components

Every entity that has been instantiated (promoted beyond narrative description) has at minimum:

```
EntityIdentity {
  id: EntityId,
  name: String?,                      // may be unnamed ("a stone")
  description: String?,               // brief textual description for LLM consumption
  origin: EntityOrigin,               // how this entity came into existence
  created_at: NarrativeTimestamp,      // when in story-time it was instantiated
}

EntityOrigin =
  | Authored                          // placed by the story designer
  | Promoted { from_context: String } // promoted from narrative description via interaction
  | Generated { template: TemplateId }// generated by the system (e.g., a market crowd)
  | Spawned { parent: EntityId }      // created by another entity's action
```

### Communicability Profile

The four dimensions from `world_design.md`, expressed as component values:

```
CommunicabilityProfile {
  surface_area: f32,           // [0.0, 1.0] — how much of its nature is available for exchange
  translation_friction: f32,   // [0.0, 1.0] — difficulty of rendering its mode of being into narrative
  timescale: Timescale,        // the temporal register in which it operates
  reciprocity: f32,            // [0.0, 1.0] — capacity for I/Thou encounter (Buber)
}

Timescale =
  | Momentary       // flame, gesture, spoken word — seconds to minutes
  | Biographical    // human life, animal life — hours to decades
  | Generational    // institutions, traditions, forests — decades to centuries
  | Geological      // mountains, rivers, climate — centuries to millennia
  | Primordial      // fundamental forces, archetypal patterns — beyond human time
```

The communicability profile determines what the entity *can do* in the system:

| Capability | Requires |
|---|---|
| Participate in dialogue | surface_area > 0.5, translation_friction < 0.5, reciprocity > 0.3 |
| Have relational web edges | surface_area > 0.3, reciprocity > 0.1 |
| Receive a psychological frame | surface_area > 0.4, has tensor elements |
| Exert narrative gravity | any communicability > 0.0 (even props can have mass in context) |
| Participate in power dynamics | surface_area > 0.2, has relational edges or topological position |

These thresholds are configurable defaults, not hard rules. A story designer can override them — if the singing sword should participate in dialogue despite being an object, they raise its surface_area and reciprocity.

### Tensor Components

Any entity can acquire tensor element components. The full set from `tensor-schema-spec.md` is available, but most entities carry only a subset:

```
// A Character (Sarah) might have:
PersonalityAxes, Capacities, Values, Motivations, EmotionalStates, EchoPatterns

// A Presence (the Shadowed Wood) might have:
PersonalityAxes(mood, hostility),  // limited set
EmotionalStates(darkening),        // reactive state

// A Condition (the economy) might have:
// No tensor elements — communicates through effects on other entities

// A Prop (a stone) might have:
// No tensor elements — but could acquire them if promoted
```

The tensor element types are already component-shaped — they have IDs, temporal layers, and can be independently attached or removed. The Entity model makes this explicit: tensor elements are ECS components, not fields on a Character struct.

### Persistence Components

```
PersistenceProfile {
  persistence_mode: PersistenceMode,
  decay_rate: DecayRate?,             // how quickly it fades when not engaged
  last_interaction: NarrativeTimestamp?,
  narrative_weight: f32,              // [0.0, 1.0] — accumulated significance
}

PersistenceMode =
  | Ephemeral       // exists only while actively engaged; dissolves on disengagement
  | Persistent      // tracked between scenes; decays over time without interaction
  | Anchored        // persists regardless of interaction (authored entities, key props)
  | Permanent       // cannot be removed from the system (characters, world features)

DecayRate {
  time_constant: f32,                // half-life in scene-equivalents
  distance_factor: f32,              // how much narrative distance accelerates decay
  narrative_weight_floor: f32,       // narrative_weight below which decay begins
  interaction_resets: bool,           // does any interaction reset the decay clock?
}
```

**Narrative weight** is the key measure of an entity's accumulated significance. It increases through interaction, mention, emotional association, and authorial emphasis. It decreases through decay. An entity whose narrative weight drops below the decay floor begins fading; one that reaches zero is dissolved.

### Relational Components

Entities can participate in the relational web if their communicability profile permits it:

```
RelationalPresence {
  edges: Vec<DirectedEdge>,          // relationships to other entities
  topological_position: TopologicalRole?, // gate, bridge, hub, periphery, isolate
}
```

Not all entities need this component. A stone has no relational presence (unless it becomes "the stone he threw at me," at which point it acquires a relational edge to the thrower and the target). The relational web specification in `relational-web-tfatd.md` defines the edge structure; this component makes an entity eligible to participate.

---

## The Lifecycle

Entities move through a lifecycle driven by interaction, narrative weight, and decay. The transitions are not discrete jumps but gradual processes — components are added incrementally as an entity gains significance, and removed incrementally as it fades.

### Promotion

An entity is promoted when something in the narrative singles it out for attention.

```
Promotion triggers:
  1. Player interaction    — "I pick up the stone" → stone becomes Ephemeral Entity
  2. Agent mention         — Narrator describes the "ancient oak" with emphasis → Presence
  3. Narrative event       — the sword breaks → sword gains EmotionalState(broken)
  4. Authorial placement   — designer marks the river as significant → Anchored Entity
  5. Accumulated reference — "the road" mentioned 5 times → crosses weight threshold
```

**Promotion is incremental**. Picking up a stone gives it EntityIdentity and PersistenceProfile(Ephemeral). Examining it might add a description. Discovering it's warm to the touch might add a CommunicabilityProfile. Learning it was the hearthstone of a burned village might add narrative_weight and promote it to Persistent. Finding it hums near ley lines might add a CharacterCapacity(supernatural). Each step adds components; no step requires a type change.

### Demotion and Decay

Entities that lose engagement decay along their configured curve:

```
Decay process:
  1. Last interaction recedes beyond decay threshold
  2. Narrative weight begins decreasing
  3. Non-essential components are shed (emotional states first, then relational edges)
  4. Entity reaches Ephemeral state (identity + minimal components)
  5. If narrative weight reaches zero and no anchoring, entity dissolves
```

**What dissolution means**: The entity's ID is retired. Its components are removed. Any relational edges pointing to it are marked as referencing a dissolved entity (which may itself be narratively meaningful — "the thing I lost"). The event ledger retains records of the entity's existence, so queries like "was there ever a stone here?" can still be answered.

**Decay is not deletion**. An entity at narrative_weight 0.05 is barely present — a fading memory, a half-forgotten detail. It can be re-promoted if something brings it back to attention. Only dissolution is irreversible.

### The Flower and the Stone

Two examples from the design discussion that illustrate the lifecycle:

**The flower**: A player picks a flower in a meadow. The flower is promoted to Ephemeral Entity with EntityIdentity("a wildflower"), PersistenceProfile(Ephemeral, decay on disengagement). The player carries it. If they give it to a character, it gains a relational edge (gift-bond) and its narrative weight increases — it is now "the flower she gave me." If instead they drop it by the roadside, it decays and dissolves within a scene or two.

**The stone**: A player picks up a stone and skips it across water. The stone is promoted to Ephemeral, interacted with briefly, and dissolved when it sinks. But if the player keeps the stone — puts it in a pocket, touches it when nervous — it accumulates narrative weight through repeated interaction. It might acquire EmotionalState(comfort, slow decay) as it becomes associated with a calming ritual. Eventually it could become "the stone from the river where she first saw the other side" — a Persistent Entity with meaningful narrative weight and thematic resonance, despite being a rock.

---

## Communicability and Power

The communicability profile determines how an entity participates in power dynamics — and crucially, it does so without requiring the entity to be a character.

### Power Through Communicability

From `power.md`: power is relational, emergent, and non-moral. It arises from the configuration of substrate dimensions and network topology in context. The Entity model extends this to non-character entities:

- **A river** has enormous surface area of communicability but high translation friction. Its power is exerted through material constraint (you cannot cross) and through atmosphere (the sound of rushing water, the cold). The World Agent translates this power into narrative.

- **An economy** has low surface area (it is abstract, invisible) but its effects are pervasive. Its power operates through conditions — scarcity, abundance, debt — that shape what characters can do. The World Agent renders economic conditions; the Storykeeper knows how they affect the narrative graph.

- **A locked door** has minimal communicability but high power in the moment. Its power is entirely topological — it sits between the player and what they want. When the player breaks it down or finds the key, its power dissolves.

- **A song** has high surface area, low translation friction, and momentary timescale. Its power is emotional and cultural — it can shift the mood of a scene, activate echoes, and create connections between characters who share the memory of hearing it.

### Network Participation

Non-character entities can participate in the relational web's topology without having full relational edges. A mountain might be a topological barrier (it separates communities), a bridge (it connects highlands to lowlands via a pass), or a gate (the pass is the only way through). These topological roles generate power independently of edge properties — consistent with the power framework's emphasis on structural position.

```
TopologicalRole =
  | Gate { controls_access_to: Vec<EntityId> }
  | Bridge { connects: (EntityId, EntityId) }
  | Hub { connected_to: Vec<EntityId> }
  | Barrier { separates: (Vec<EntityId>, Vec<EntityId>) }
  | Periphery
  | Isolate
```

---

## The World Agent's Role

The Entity model clarifies and enriches the World Agent's responsibilities:

1. **Entity lifecycle management**: The World Agent monitors for promotion triggers (player interaction with untracked things, narrative weight accumulation) and manages decay. It is the primary agent responsible for creating, promoting, and dissolving non-character entities.

2. **Communicability translation**: The World Agent translates non-character entity states into forms that other agents can use. When the Narrator needs to describe the forest, the World Agent provides the forest's current communicability — its mood, its obstacles, its atmospheric qualities — rendered from the forest's component state.

3. **Constraint enforcement**: The World Agent validates actions against entity states. A locked door constrains movement. A flooded river constrains crossing. An exhausted economy constrains purchasing. These constraints are expressed through entity components, not through ad-hoc rules.

4. **Power dynamics**: The World Agent participates in power computation for non-character entities. When the mountain's pass is blocked by snow, the mountain's topological power increases (it becomes a harder barrier). The World Agent updates the entity's state and signals the change.

---

## ECS Implementation Notes

The Entity model maps directly onto Bevy's Entity-Component-System architecture:

```rust
// Entity is Bevy's Entity — an opaque ID
// Components are Bevy Components

#[derive(Component, Debug)]
struct EntityIdentity {
    name: Option<String>,
    description: Option<String>,
    origin: EntityOrigin,
    created_at: NarrativeTimestamp,
}

#[derive(Component, Debug)]
struct CommunicabilityProfile {
    surface_area: f32,
    translation_friction: f32,
    timescale: Timescale,
    reciprocity: f32,
}

#[derive(Component, Debug)]
struct PersistenceProfile {
    persistence_mode: PersistenceMode,
    decay_rate: Option<DecayRate>,
    last_interaction: Option<NarrativeTimestamp>,
    narrative_weight: f32,
}

// Tensor elements are also components:
#[derive(Component, Debug)]
struct PersonalityAxes(Vec<PersonalityAxis>);

#[derive(Component, Debug)]
struct Motivations(Vec<Motivation>);

// ... etc.
```

**Systems** query for entities by component presence:

```rust
// Find all entities that need frame computation
fn compute_frames(
    query: Query<(Entity, &PersonalityAxes, &CommunicabilityProfile), With<PersistenceProfile>>,
) { ... }

// Find all entities that should decay
fn process_decay(
    query: Query<(Entity, &mut PersistenceProfile)>,
    time: Res<NarrativeTime>,
) { ... }

// Find all entities in a scene
fn scene_entities(
    query: Query<(Entity, &EntityIdentity, Option<&CommunicabilityProfile>)>,
    scene: Res<CurrentScene>,
) { ... }
```

**Promotion** is adding components to an existing entity. **Demotion** is removing them. **Dissolution** is despawning the entity entirely. The ECS makes all of these natural operations.

---

## Relationship to the Tensor Schema

The tensor element types in `tensor-schema-spec.md` are the *vocabulary* of entity capability. The Entity model is the *grammar* — the rules for how those capabilities are assembled, acquired, and lost.

Key points of integration:

1. **Any entity can acquire any tensor element.** The schema defines PersonalityAxis, Motivation, EmotionalState, etc. as independent types. The Entity model says these are components attachable to any entity, not reserved for characters.

2. **The communicability profile gates capability.** An entity with low surface_area cannot meaningfully use complex tensor elements — it wouldn't have enough expressiveness to manifest them. The frame computation pipeline (tensor-schema-spec.md, Frame Computation Pipeline) checks communicability before synthesizing a frame.

3. **Provenance applies to entities.** The provenance tracking from Design Decision 2 (tensor-schema-spec.md) extends to entity creation: was this entity authored, promoted from interaction, or generated by the system?

4. **Decay interacts with temporal layers.** An entity's tensor elements have temporal layers (topsoil, sediment, bedrock). Decay removes topsoil elements first, then sediment, then bedrock — consistent with the geological metaphor. A decaying entity loses its volatile emotional states before its core personality.

---

## Open Considerations

1. **Promotion heuristics**: What exactly triggers promotion? "Player picks up stone" is clear; "Narrator mentions the oak three times" is fuzzier. The promotion system needs configurable thresholds and possibly story-designer hints ("this oak is important, promote it early").

2. **Entity budget**: In a richly described scene, dozens of things could be promoted. The system needs a budget — a maximum number of tracked entities per scene, with priority based on narrative weight and recent interaction.

3. **Dissolved entity references**: When an entity dissolves, references to it (in relational edges, in the event ledger, in character memories) need graceful handling. A character who remembers "the flower she gave me" is referencing a dissolved entity — this reference is itself meaningful.

4. **Cross-scene entity tracking**: An entity created in one scene and carried to another needs to be present in the new scene's entity set. The persistence system must handle scene transitions for non-character entities.

5. **World Agent workload**: The Entity lifecycle places significant responsibility on the World Agent. Monitoring for promotion triggers across all narrative description, managing decay for all tracked entities, translating communicability for all non-character entities — this is substantial. The implementation may need to distribute this work across sub-systems or classifier agents.

6. **Communicability as relational, not absolute**: The current communicability profile stores surface_area and translation_friction as properties *of* the entity — but communicability is fundamentally *between* entities. A mountain's translation friction is enormous for a human, but might be low for a druid who has trained to listen, for a shaman with innate gifts, or for another geological presence. A dark alleyway in a noir setting might be impenetrable to most characters but legible to someone with uncanny intuition. This suggests that the profile as specified captures the *default* communicability (the entity's baseline), but actual communicability in a given interaction is computed relationally — modified by the *receiving* entity's capacities, training, innate gifts, or adjacency of type. The profile might need a relational modifier system: `effective_friction(entity_a, entity_b) = a.translation_friction * modifier(b.capacities, b.type_adjacency)`. This would preserve the simplicity of the stored profile while honoring the relational nature of communication. The druid's `CharacterCapacity(supernatural, domain: natural_communion)` would reduce friction with geological/botanical presences. The noir detective's `CharacterCapacity(perception, domain: atmosphere)` would reduce friction with environmental moods. This remains an open design question — the stored profile is a reasonable starting point, but the relational dimension needs resolution before implementation.
